import "module:std" as std
import { AuthEndpoint } from "./auth.ht"

var HttpClient = std.HttpClient

class Converter {
  static fun toSpotubeMatchObject(res: List) -> List<Map> {
    return res.map((d) {
      return {
        "id": d["id"].toString(),
        "title": d["title"],
        "artists": [d["artist"]],
        "duration": d["duration"] * 1000,
        "thumbnail": d["albumCover"],
        "externalUri": "https://dab.yeet.su/search?q=${d["title"]}%20${d["artist"]}",
      }.toJson()
    }).toList()
  }

  static fun toSpotubeStreamObject(hiResData: Map, lowResData: Map, cookieHeader: string) -> List {
    return [
      {
        "url": hiResData["url"],
        "container": "flac",
        "type": "lossless",
        "bitDepth": 24,
        "sampleRate": 96000,
        "headers": { "Cookie": cookieHeader }.toJson(),
      }.toJson(),
      {
        "url": lowResData["url"],
        "container": "aac",
        "type": "lossy",
        "codec": "aac",
        "bitrate": 320000,
        "headers": { "Cookie": cookieHeader }.toJson(),
      }.toJson()
    ]
  }
}

class AudioSourceEndpoint {
  var api: HttpClient
  // Accept the full AuthEndpoint so we always read the latest credentials
  var auth: AuthEndpoint

  construct (this.api, this.auth)

  fun getCookieHeader() -> string {
    return auth.getCookieHeaderValue()
  }

  fun buildOptions() -> Map {
    final cookie = getCookieHeader()
    return {
      "headers": { "Cookie": cookie }.toJson()
    }.toJson()
  }

  // List of containers and their supported qualities
  get supportedPresets -> List {
    return [
      {
        "type": "lossless",
        "name": "flac",
        "qualities": [
          { "bitDepth": 24, "sampleRate": 96000 }.toJson(),
          { "bitDepth": 24, "sampleRate": 44100 }.toJson(),
          { "bitDepth": 16, "sampleRate": 44100 }.toJson()
        ]
      }.toJson(),
      {
        "type": "lossy",
        "name": "aac",
        "qualities": [ { "bitrate": 320000 }.toJson() ]
      }.toJson(),
    ]
  }

  /// Perform a search request and retry once after re-authentication if a 403
  /// is received.
  fun searchWithRetry(query: string) {
    return api.get_req(
      "/search",
      queryParameters: {
        "q": query,
        "type": "track",
        "limit": "5"
      }.toJson(),
      options: buildOptions()
    ).then((res) {
      if (res.statusCode == 403) {
        // Session expired — re-authenticate then retry
        return auth.reAuthenticate().then((_) {
          return api.get_req(
            "/search",
            queryParameters: {
              "q": query,
              "type": "track",
              "limit": "5"
            }.toJson(),
            options: buildOptions()
          )
        })
      }
      return res
    })
  }

  /// Find matching audio sources for a given track.
  /// @param track - Map<SpotubeTrackObject>
  /// @returns Future<List<SpotubeAudioSourceMatchObject>>
  fun matches(track: Map) -> List {
    final hasISRC = track["isrc"] != null && track["isrc"].isNotEmpty
    final query = hasISRC
      ? track["isrc"]
      : "${track["name"]} ${track["artists"][0]["name"]}"

    return searchWithRetry(query).then((res) {
      if (hasISRC && (res.data["tracks"] == null || res.data["tracks"].isEmpty)) {
        // ISRC search returned nothing — fall back to title+artist
        final fallbackQuery = "${track["name"]} ${track["artists"][0]["name"]}"
        return searchWithRetry(fallbackQuery).then((fallbackRes) {
          return Converter.toSpotubeMatchObject(fallbackRes.data["tracks"])
        })
      }
      return Converter.toSpotubeMatchObject(res.data["tracks"])
    })
  }

  /// For the given match, return all available streams.
  /// @param match - Map<SpotubeAudioSourceMatchObject>
  /// @returns Future<List<SpotubeAudioSourceStreamObject>>
  fun streams(match: Map) -> List {
    return api.get_req(
      "/stream",
      queryParameters: {
        "trackId": match["id"],
        "quality": 27
      }.toJson(),
      options: buildOptions()
    ).then((hiRes) {
      if (hiRes.statusCode == 403) {
        // Session expired — re-authenticate then retry both stream requests
        return auth.reAuthenticate().then((_) {
          return api.get_req(
            "/stream",
            queryParameters: {
              "trackId": match["id"],
              "quality": 27
            }.toJson(),
            options: buildOptions()
          ).then((hiRes2) {
            return api.get_req(
              "/stream",
              queryParameters: {
                "trackId": match["id"],
                "quality": 5
              }.toJson(),
              options: buildOptions()
            ).then((lowRes2) {
              return Converter.toSpotubeStreamObject(hiRes2.data, lowRes2.data, getCookieHeader())
            })
          })
        })
      }

      return api.get_req(
        "/stream",
        queryParameters: {
          "trackId": match["id"],
          "quality": 5
        }.toJson(),
        options: buildOptions()
      ).then((lowRes) {
        return Converter.toSpotubeStreamObject(hiRes.data, lowRes.data, getCookieHeader())
      })
    })
  }
}

export { AudioSourceEndpoint }
