import "module:std" as std

var HttpClient = std.HttpClient
var HttpResponse = std.HttpResponse
var RequestOptions = std.RequestOptions

class Converter {
  static fun toSpotubeMatchObject(res: List) -> List<Map> {
    return res.map((d){
      return {
        "id": d["id"].toString(),
        "title": d["title"],
        "artists": [d["artist"]],
        "duration": d["duration"] * 1000,
        "thumbnail": d["albumCover"],
        "externalUri": "https://dab.yeet.su/search?q=${d["title"]}%20${d["artist"]}",
      }.toJson()
    }).toList()
  }

  static fun toSpotubeStreamObject(streams: List, cookieHeader: string) -> List {
    return [
      {
        "url": streams[0]["url"],
        "container": "flac",
        "type": "lossless",
        "bitDepth": 24,
        "sampleRate": 96000,
        "headers": {"Cookie": cookieHeader}.toJson(),
      }.toJson(),
      {
        "url": streams[1]["url"],
        "container": "aac",
        "type": "lossy",
        "codec": "aac",
        "bitrate": 320000,
        "headers": {"Cookie": cookieHeader}.toJson(),
      }.toJson()
    ]
  }
}

class AudioSourceEndpoint {
  var api: HttpClient
  var auth: Map

  construct (this.api, this.auth)

  fun getCookieHeader() -> string {
    final session = auth?["session"]
    if (session == null) return ""
    
    if (session is List) {
      return session.map((d)=>d.split("; ")[0]).join("; ")
    }
    return session.toString().split("; ")[0]
  }

  // List of containers and their supported qualities
  get supportedPresets -> List {
    return [
      { 
        type: "lossless", 
        name: "flac",
        qualities: [
          { bitDepth: 24, sampleRate: 96000 },
          { bitDepth: 24, sampleRate: 44100 },
          { bitDepth: 16, sampleRate: 44100 }
        ]
      }.toJson(),
      { type: "lossy", name: "mp3", qualities: [ { bitrate: 320000 } ] }.toJson(),
    ]
  }
  
  /// Find matching audio sources for a given track. It can return one or multiple matches.
  /// The first match is considered the best match.
  /// @param track - Map<SpotubeTrackObject>
  /// @returns Future<List<SpotubeAudioSourceMatchObject>>
  fun matches(track: Map) -> List {
    final hasISRC = track["isrc"] != null && track["isrc"].isNotEmpty
    var query = hasISRC ? track["isrc"] 
      : "${track["name"]} ${track["artists"][0]["name"]}"

    final cookieHeader = getCookieHeader()
    print("[DEBUG] matches() - Cookie header: ${cookieHeader}")

    return api.get_req(
      "/search",
      queryParameters: {
        "q": query,
        "type": "track",
        "limit": "5"
      }.toJson(),
      options: RequestOptions(headers: {"Cookie": cookieHeader}.toJson())
    ).then((res) {
      print("[DEBUG] matches() - Response status: ${res.statusCode}")
      print("[DEBUG] matches() - Response data: ${res.data}")
      
      if(hasISRC && (res.data["tracks"] == null || res.data["tracks"].isEmpty)) {
        return api.get_req(
          "/search",
          queryParameters: {
            "q": "${track["name"]} ${track["artists"][0]["name"]}",
            "type": "track",
            "limit": "5"
          }.toJson(),
          options: RequestOptions(headers: {"Cookie": cookieHeader}.toJson())
        ).then((res)=> Converter.toSpotubeMatchObject(res.data["tracks"]))
      }
      
      return Converter.toSpotubeMatchObject(res.data["tracks"])
    })
  }

  /// For the given match, return all available streams.
  /// Each stream represents a unique combination of container and quality.
  /// @param match - Map<SpotubeAudioSourceStreamObject>
  /// @returns Future<List<SpotubeAudioSourceStreamObject>>
  fun streams(match: Map) -> List {
    final cookieHeader = getCookieHeader()
    print("[DEBUG] streams() - Cookie header: ${cookieHeader}")
    
    return api.get_req(
      "/stream",
      queryParameters: {
        "trackId": match["id"],
        "quality": 27
      }.toJson(),
      options: RequestOptions(headers: {"Cookie": cookieHeader}.toJson())
    ).then((hiRes){
      print("[DEBUG] streams() - hiRes status: ${hiRes.statusCode}")
      
      return api.get_req(
        "/stream",
        queryParameters: {
          "trackId": match["id"],
          "quality": 5
        }.toJson(),
        options: RequestOptions(headers: {"Cookie": cookieHeader}.toJson())
      ).then((lowRes){
        print("[DEBUG] streams() - lowRes status: ${lowRes.statusCode}")
        
        return Converter.toSpotubeStreamObject([
          hiRes.data,
          lowRes.data,
        ], cookieHeader)
      })
    })
  }
}

export { AudioSourceEndpoint }